import sys
# sys.stdin = open('input.txt')
input = sys.stdin.readline

"""
# 모든 전깃줄이 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수 구하기
1. 위치의 번호는 500 이하의 자연수
2. 전깃줄의 개수는 100 이하의 자연수
@ 풀이
(1) 경우의 수
A = [8]
B = [1]
개수 0
A = [8, 3]
B = [1, 9]
개수 0  1
없애기(1, 8) or (3, 9)
A = [8, 3, 2]
B = [1, 9, 2]
개수 0  1  1
없애기(1, 8)
A = [8, 3, 2, 4]
B = [1, 9, 2, 1]
개수 0  1  1  2
없애기(1, 8), (4, 1)
A = [8, 3, 2, 4, 6]
B = [1, 9, 2, 1, 4]
개수 0  1  1  2  3
없애기(1, 8), (4, 1), (3, 9)
A = [8, 3, 2, 4, 6, 10]
B = [1, 9, 2, 1, 4, 10]
개수 0  1  1  2  3  3
없애기(1, 8), (4, 1), (3, 9)
A = [8, 3, 2, 4, 6, 10, 9]
B = [1, 9, 2, 1, 4, 10, 7]
개수 0  1  1  2  3  3   3
없애기(1, 8), (4, 1), (3, 9)
A = [8, 3, 2, 4, 6, 10, 9, 7]
B = [1, 9, 2, 1, 4, 10, 7, 6]
개수 0  1  1  2  3  3   3  3
없애기(1, 8), (4, 1), (3, 9)
(2) A를 오름차순으로 정렬하고 B는 겹치지 않아야 하므로 가장 긴 증가하는 수열 구하기
"""


# dp 함수
def dp(N, AB):
    dp = [0] * (N + 1)
    
    # 최대로 전기줄이 존재할 수 있는 수를 구하기
    for j in range(1, N + 1):
        # 기본 값 부여
        dp[j] = 1
        for k in range(1, j + 1):
            # 이전 수보다 현재 수가 더 크다면
            if AB[j][1] > AB[k][1]:
                # 현재까지 비교한 수중 가장 큰 길이와 이전의 길이랑 비교 후 교체
                dp[j] = max(dp[j], dp[k] + 1)
    
    # 최대 전기줄에서 존재할 수 있는 전기줄 수를 빼면 제거해야할 수가 나옴
    return N - max(dp)


# 전깃줄의 개수: N
N = int(input())

# 전깃줄 연결 현황
AB = []
for i in range(1, N + 1):
    x, y = map(int, input().split())
    AB.append((x, y))

# A 기준으로 정렬
AB.sort()

# 인덱스 조정
AB.insert(0, (0, 0))

print(dp(N, AB))